#!/usr/bin/env python

import argparse
import sys
import QCParserModules as qc



class QCParser(object):
    # code modified from example on http://chase-seibert.github.io/blog/2014/03/21/python-multilevel-argparse.html

    #create base parser
    def __init__(self):
        parser = argparse.ArgumentParser(description="Tools for parsing output from several commonly available bioinformatic tools",
                                     usage = '''qcparser <tool> [<args>]
                                     Tools:
                                        fastqc      parse fastqc text output
                                        flagstat    parse samtools flagstat output
                                        capture     parse/summarize output from bedtools intersect
                                        coverage    parse/summarize output from samtools depth
                                        trimmomatic parse output from trimmomatic
                                        insertsize  parse output from Picard CollectInsertSizeMetrics
                                        merge       merge parsed output files from multiple tools (column-wise) or across multiple samples (row-wise)''')

        parser.add_argument('command', help='tools to run')

        #parse args and determine which tool to run
        args = parser.parse_args(sys.argv[1:2])
        if not hasattr(self, args.command):
            print 'Unrecognized command'
            parser.print_help()
            exit(1)

        #use dispatch pattern to invoke method with same name
        getattr(self, args.command)()




    def fastqc(self):
        #function for parsing fastqc text output
        parser = argparse.ArgumentParser(description="Parse fastqc text output")

        #expects text output file from Fastqc v0.11.5 (fastqc_data.txt)
        parser.add_argument('-i', "--input", action='store', dest='fastqc_text_output', required=True, help="path to fastqc text output to parse")
        parser.add_argument('-p', '--headersuffix', action='store', dest='output_header_suffix', required=False, default="", help="name to be appended to column headers (e.g. Num_Reads becomes Num_Reads_R1 with 'R1' as suffix")
        parser.add_argument('--paired', action="store_true", dest="is_paired", help="flag indicating sequence data is part of pair and that sequence counts will be doubled")
        parser.add_argument('--omitnumreads', action="store_true", dest="omit_num_reads", help="omit number of reads from summary")
        parser.add_argument('--omitlowqual', action="store_true", dest="omit_low_qual", help="omit number of low quality reads from summary")
        parser.add_argument('--omitseqlen', action='store_true', dest="omit_seq_len", help="omit seq length distribution from summary")
        parser.add_argument('--omitgc', action='store_true', dest="omit_gc", help="omit gc content from summary" )
        parser.add_argument('--omittestresults', action='store_true', dest="omit_tests", help="omit reporting test results in summary")
        parser.add_argument('--omitfilename', action='store_true', dest="omit_filename", help="omit reporting name of fastq file")
        parser.add_argument('--delimiter', action="store", dest="delim", default='\t', help="delimiter for output. DEFAULT=\\t")

        #parse arguments
        args = parser.parse_args(sys.argv[2:])

        #parser fastqc output
        summary = qc.parse_fastqc(args.fastqc_text_output, args.output_header_suffix, args.is_paired, args.omit_num_reads, args.omit_low_qual, args.omit_seq_len, args.omit_gc, args.omit_tests, args.omit_filename)

        #print to stdout
        qc.print_summary(summary, args.delim)



    def flagstat(self):
        #function for parsing samtools flagstat output
        parser = argparse.ArgumentParser(description="Parse samtools flagstat output")

        # expects flagsat output from Samtools v1.31
        parser.add_argument('-i', "--input", action='store', dest='samtools_flagstat_output', required=True, help="path to output from samtools flagstat")
        parser.add_argument('--omitpcrdup', action="store_true", dest="omit_pcr_dup", help="omit PCR duplication percentage from summary")
        parser.add_argument('--omitnumalign', action="store_true", dest="omit_num_align", help="omit number of aligned reads from summary")
        parser.add_argument('--omitalignrate', action="store_true", dest="omit_align_rate", help="omit alignment rate from summary")
        parser.add_argument('--delimiter', action="store", dest="delim", default='\t', help="delimiter for output. DEFAULT=\\t")

        # parse arguments
        args = parser.parse_args(sys.argv[2:])

        #parse flagstat output
        summary = qc.parse_flagstat(args.samtools_flagstat_output, args.omit_pcr_dup, args.omit_num_align)

        #print to stdout
        qc.print_summary(summary, args.delim)




    def capture(self):
        #function for parsing bedtools intersect output to summarize capture efficiency

        parser = argparse.ArgumentParser(description="Summarize capture target efficiency efficiency from bedtools intersect output")

        # expects output from Bedtools Intersect with the -c option
        parser.add_argument('-i', "--input", action='store', dest='bedtools_intersect_output', required=True,
                            help="path to file containing output from bedtools intersect")

        #add optional argument for specifying name of target type
        parser.add_argument("--targettype", action='store', dest='target_type', required=False, default="Target",
                            help="name of target type (e.g. Exonic, Intronic) that will be used for column header")

        # parse arguments
        args = parser.parse_args(sys.argv[2:])

        # parse output file
        summary = qc.parse_bedtools_intersect(args.bedtools_intersect_output, args.target_type)

        #print to stdout
        qc.print_summary(summary)




    def coverage(self):
        #function for parsing samtools depth output to summarize sequencing coverage
        parser = argparse.ArgumentParser(description="Summarize sequencing depth from samtools depth output")

        # expects output from Bedtools Intersect with the -c option
        parser.add_argument('-i', "--input", action='store', dest='samtools_depth_output', required=True, help="path to file containing output from samtools depth")
        parser.add_argument('--ct', action='append', dest='cutoffs', default=[5], type=int, help="Determine percentage of bases covered above this depth (INT). Can be specified multiple times for multiple cutoffs.")

        # parse arguments
        args = parser.parse_args(sys.argv[2:])

        # parse output file
        summary = qc.parse_samtools_depth(args.samtools_depth_output, args.cutoffs)

        # print to stdout
        qc.print_summary(summary)




    def trimmomatic(self):
        #function for parsing trimmomatic stndoutput to determine read trimming statistics
        parser = argparse.ArgumentParser(description="Parse trimmomatic output")

        # expects file containing standard output from Trimmomatic v0.32
        parser.add_argument('-i', "--input", action='store', dest='trimmomatic_output', required=True, help="path to file containing standard output from trimmomatic")
        parser.add_argument('--omitnumraw', action="store_true", dest="omit_num_raw", help="omit number of reads before trimming from summary")
        parser.add_argument('--omitnumtrimmed', action="store_true", dest="omit_num_trimmed", help="omit number of reads after trimming from summary")
        parser.add_argument('--omitpassrate', action="store_true", dest="omit_trim_rate", help="omit trimming pass rate from summary")
        parser.add_argument('--delimiter', action="store", dest="delim", default='\t', help="delimiter for output. DEFAULT=\\t")

        # parse arguments
        args = parser.parse_args(sys.argv[2:])

        # parse trimmomatic output
        summary = qc.parse_trimmomatic(args.trimmomatic_output, args.omit_num_raw, args.omit_num_trimmed)

        # print to stdout
        qc.print_summary(summary, args.delim)




    def insertsize(self):
        #function for parsing output from Picard CollectInsertSummaryMetrics
        parser = argparse.ArgumentParser(description="Parse picard CollectInsertSummaryMetrics output")

        # expects output from Picard CollectInsertSummaryMetrics v2.9.0
        parser.add_argument('-i', "--input", action='store', dest='picard_insert_summary_metrics_output', required=True, help="path to file containing output from Picard CollectInsertSummaryMetrics")
        parser.add_argument('--delimiter', action="store", dest="delim", default='\t', help="delimiter for output. DEFAULT=\\t")

        # parse arguments
        args = parser.parse_args(sys.argv[2:])

        # parse output file
        summary = qc.parse_picard_insert_size_metrics(args.picard_insert_summary_metrics_output)

        # print to stdout
        qc.print_summary(summary, args.delim)




    def merge(self):
        #function for merging summary files from multiple analyses into a single summary file
        #Can either merge by column to merge summaries from a single sample or by row to merge summaries from multiple samples

        parser = argparse.ArgumentParser(description="Parse picard CollectInsertSummaryMetrics output")

        #expects list of parsed output summaries generated by this program. Assumes all files have the same delimiter
        parser.add_argument('-i', '--input', nargs='+', action='store', dest='summary_files', required=True, help="space-delimited list of output files to merge")
        parser.add_argument('--sample', action='store', dest='sample_name', required=False, default=None, help="sample name to include as first output column if merging by column. No effect if mergins by row.")
        parser.add_argument('--multisample', action='store_true', dest='multisample', help="flag indicating files are from different samples and are to be merged by row. DEFAULT: merge files as columns from a single sample.")
        parser.add_argument('--delimiter', action="store", dest="delim", default='\t', help="delimiter for output/output. DEFAULT=\\t")

        #parse arguments
        args = parser.parse_args(sys.argv[2:])

        #merge files into a single summary table
        summary = qc.merge_summary_files(args.summary_files, args.sample_name, args.multisample, args.delim)

        #print to stdout
        qc.print_summary(summary, args.delim)





if __name__=='__main__':
    try:
        QCParser()
    except Exception:
        sys.exit(1)